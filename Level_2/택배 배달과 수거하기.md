
## 택배 배달과 수거하기 (Lv.2)

[https://school.programmers.co.kr/learn/courses/30/lessons/150369]

### 기록

1. **배달할 상자 개수와 수거할 상자 개수에 대하여**
    
    처음엔 두 배열을 합하여 하나의 배열로 만든 후, cap의 2배에 해당하는 개수만큼 뒤에서 부터 삭제하는 방식을 떠올렸다.
    
    하지만 경우에 따라 최적해가 나오지 않으므로 각각 분리해서 상자 개수를 해결해야 한다고 생각했다.
    
2. **가장 먼 집부터 해결**
    
    배달이든 수거든 해결되지 않은 집을 찍고 와야 하므로, 인덱스를 뒤에서부터 앞으로 땡겨오면서 값이 0이 아닌 집를 찾는다.
    
3. **두 배열의 처리 방식**
    
    두 배열의 처리 방식의 유사성이 있기 때문에 한 함수로 통일 시켰다.
    
4. **고쳐야할 점**
    - (2)을 설계하면서 처음에는 배열의 모든 요소를 조회하였다. 하지만 이 방식은 O(n)의 시간 복잡도를 가지기에 테스트 결과 중 일부가 시간초과로 실패하였다. 인덱스를 저장하여 재활용한다는 아이디어는 GPT의 도움을 받았다.

### 제출 코드

```cpp
#include <string>
#include <vector>

using namespace std;

int lastNonZeroIndex(const vector<int>& v, int idx){
    while(idx >= 0 && v[idx] == 0) idx--;
    return idx;
}

void deliveryAndPickup(vector<int>& v, int cap, int distance){
    int curr_cap = cap;
    for(int i = distance-1; i >= 0; i--){
        if(v[i] == 0) continue;
        if(curr_cap == 0) return;
        if(v[i] <= curr_cap){
            curr_cap -= v[i];
            v[i] = 0;
        } else {
            v[i] -= curr_cap;
            curr_cap = 0;
        }
    }
}

long long solution(int cap, int n, vector<int> deliveries, vector<int> pickups) {
    long long answer = 0;
    int dLastNonZero = lastNonZeroIndex(deliveries, n-1);
    int pLastNonZero = lastNonZeroIndex(pickups, n-1);
    while (dLastNonZero >= 0 || pLastNonZero >= 0){
        int distance = max(dLastNonZero, pLastNonZero) + 1;
        answer += distance * 2;
        deliveryAndPickup(deliveries, cap, distance);
        deliveryAndPickup(pickups, cap, distance);
        dLastNonZero = lastNonZeroIndex(deliveries, dLastNonZero);
        pLastNonZero = lastNonZeroIndex(pickups, pLastNonZero);
    }
    return answer;
}
```