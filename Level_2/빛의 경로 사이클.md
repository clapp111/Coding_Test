
## 빛의 경로 사이클 (Lv.2)

https://school.programmers.co.kr/learn/courses/30/lessons/86052

### 기록

1. **유향 그래프의 구현**
    
    해당 문제는 일반적인 그래프 문제에서 방향 상태가 추가된 유향 그래프를 다루는 문제이다.
    
    따라서 노드별로 4가지 방향을 나타내는 배열을 추가하여 visited[x][y][dir]을 만들었다.
    
    dir 방향으로 이동하면 x와 y 또한 해당 방향으로 인덱스를 이동하여야한다.
    
2. **방향 전환**
    
    이 문제에서 방향은 4가지이고 노드가 ‘L’, ‘R’일 때만 방향의 전환이 있으면 되므로, 이 안에서 switch문으로 각각 구현하였다.
    
    물론 공식이 있겠지만 경우가 적으므로 원시적으로 구현하였다.
    
3. **인덱스 정리**
    
    이동을 하고 나면 인덱스가 배열의 범위 밖으로 벗어나는 경우가 있다.
    
    이럴때는 x = (x + h) % h 공식으로 인덱스를 다듬으면 된다. 자주 사용되므로 기억하는 것이 좋다.
    
4. **고쳐야할 점**
    - 방향이 4가지로 고정되어 있어도, 나중에 더 일반화된 상황에서는 공식이 필요할 수 있다. 귀찮더라도 규칙성을 파악하고 식을 세우는 연습을 하자.
    - 유향 그래프 문제는 처음이라 방향을 설정하는 방법에서 꽤 많은 시간이 소모되었다. 다음에는 빠르게 해결할 수 있게 연습해놓자.

### 제출 코드

```cpp
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

vector<int> solution(vector<string> grid) {
    vector<int> answer;
    // visited[x][y][dir] : (x, y) 위치에서 dir 방향으로 출발한 적이 있는지 여부
    // 0: 위, 1: 오른, 2: 아래, 3: 왼
    int h = grid.size();
    int w = grid[0].size();
    vector<vector<vector<bool>>> visited(h, vector<vector<bool>>(w, vector<bool>(4, false)));
    vector<vector<int>> move = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}}; // 위, 오른, 아래, 왼

    for(int x = 0; x < h; x++){
        for(int y = 0; y < w; y++){
            for(int dir = 0; dir < 4; dir++){
                if(visited[x][y][dir]) continue;
                // 해당 노드에서 dir 방향으로 빛 쏘기 시작
                int current_x = x, current_y = y, current_dir = dir;
                int count = 0;
                while(!visited[current_x][current_y][current_dir]) {
                    visited[current_x][current_y][current_dir] = true;
                    char c = grid[current_x][current_y];
                    if(c == 'L'){
                        switch(current_dir) {
                            case 0: current_dir = 3; break;
                            case 1: current_dir = 0; break;
                            case 2: current_dir = 1; break;
                            case 3: current_dir = 2; break;
                        }
                    } else if(c == 'R'){
                        switch(current_dir) {
                            case 0: current_dir = 1; break;
                            case 1: current_dir = 2; break;
                            case 2: current_dir = 3; break;
                            case 3: current_dir = 0; break;
                        }
                    }
                    current_x = (current_x + move[current_dir][0] + h) % h;
                    current_y = (current_y + move[current_dir][1] + w) % w;
                    count++;
                }
                answer.push_back(count);
            }
        }
    }
    sort(answer.begin(), answer.end());
    return answer;
}
```