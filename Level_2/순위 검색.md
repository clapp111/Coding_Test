
## 순위 검색 (Lv.2)

https://school.programmers.co.kr/learn/courses/30/lessons/72412

### 기록

1. **효율화(시간 복잡도 측면)**
    
    전체 query 조건은 4x3x3x3 = 108가지(각 “-” 포함)이며, 각 info는 4개의 조건을 가지므로 2^4 = 16가지의 key로 확장하여 value를 중복으로 저장했다. 
    
    따라서 query에서 “-”가 조건으로 들어와도, 전체 조건은 이미 map에 등록되어있다.
    
2. **고쳐야할 점**
    - 처음 설계할 때는 각 query가 모든 info를 조회하면서 직접 카운트하는 방식으로 진행했다. 하지만 효율성 테스트에서 시간초과로 실패했다. 이유는 위 방식대로 할 시, 시간 복잡도가 O(query * info)가 되기 때문이다. 쉬운 길이 보였으면 더 효율적으로 다룰 방법도 생각해보자.
    - 이제 기본적인 C++ 문법은 숙지하였으니, 메모리 효율성을 위해 auto&을 사용하는 방법도 생각하면서 설계해보자.

### 제출 코드

```cpp
#include <string>
#include <vector>
#include <sstream>
#include <unordered_map>

using namespace std;

vector<int> solution(vector<string> info, vector<string> query) {
    vector<int> answer;
    unordered_map<string, vector<int>> info_map;
    for(string i : info){
        stringstream ss(i);
        string language, position, career, food;
        int score;
        ss >> language >> position >> career >> food >> score;
        vector<string> lang = {language, "-"};
        vector<string> pos = {position, "-"};
        vector<string> car = {career, "-"};
        vector<string> foo = {food, "-"};
        for(string l : lang){
            for(string p : pos){
                for(string c : car){
                    for(string f : foo){
                        string key = l + " " + p + " " + c + " " + f;
                        info_map[key].push_back(score);
                    }
                }
            }
        }
    }
    for(string q : query){
        stringstream ss(q);
        string language, position, career, food, dummy;
        int q_score;
        ss >> language >> dummy >> position >> dummy >> career >> dummy >>  food >> q_score;
        string q_info = language + " " + position + " " + career + " " + food;
        vector<int> scores = info_map[q_info];
        int count = 0;
        for(int s : scores){
            if(s >= q_score) count++;
        }
        answer.push_back(count);
    }
    return answer;
}
```