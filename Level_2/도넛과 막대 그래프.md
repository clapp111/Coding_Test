
## 도넛과 막대 그래프 (Lv.2)

[https://school.programmers.co.kr/learn/courses/30/lessons/258711]

### 기록

1. **unordered_map<key_type, value_type>을 사용**
    
    진출/진입 간선을 계산하기 위해 각각 unordered_map을 사용했다. 
    
    vector를 사용해도 무리는 없을 것으로 예상된다.
    
2. **시작 노드 구하기**
    
    문제에서는 그래프의 수의 합은 2이상이라고 하였으므로, 시작 노드의 진출 간선 역시 2개 이상이고 진입 간선은 없어야한다. 
    
    이 조건을 기반으로 위에서 생성한 unordered_map을 순회하면서 시작 노드를 찾는다.
    
3. **도넛, 막대, 8자 그래프의 간선의 특징을 파악한다.**
    
    모든 그래프 문제를 진출/진입 차수로 풀 수 있는 건 아니다.
    
    - 언제 차수가 핵심이 되는가?
        1. 그래프의 형태(구조)를 구분하는 문제 ← *이번 문제의 경우*
        2. 위상 정렬 / 선후관계 문제
        3. “유향 그래프” + “한 방향 흐름” 문제
4. **고쳐야할 점**
    - 이 문제를 봤을 때, 간선의 갯수를 기반으로 그래프의 수를 구할 수 있다는 직관으로 시작하였다. 하지만 예시로 주어진 경우 외에도 사용할 수 있는 방법이 있을지는 확신하지 못했다. (이 부분은 GPT의 도움을 받았다)

### 제출 코드
```cpp
#include <string>
#include <vector>
#include <unordered_map>

using namespace std;

vector<int> solution(vector<vector<int>> edges) {
    int start = 0, donut = 0, stick = 0, figure8 = 0, graph = 0, node = 0;
    unordered_map<int, int> out;
    unordered_map<int, int> in;

    for(vector<int> edge : edges){
        out[edge[0]]++;
        in[edge[1]]++;
        node = max(node, max(edge[0], edge[1]));
    }

    for(int i = 1; i < node + 1; i++){
        if(out[i] >= 2 && in[i] == 0) {
            start = i;
            graph = out[i];
        }
    }
    for(int i = 1; i < node + 1; i++){
        if(i == start) continue;
        if(out[i] == 0 && in[i] >= 1) stick++;
        if(out[i] == 2 && in[i] >= 2) figure8++;
    }
    donut = graph - stick - figure8;
    return {start, donut, stick, figure8};
}
```