
## 단체 사진 찍기 (Lv.2)

[https://school.programmers.co.kr/learn/courses/30/lessons/1835]

### 기록

1. **백트래킹(DFS) 사용**
    
    해당 문제를 보고 조건이 있는 순열의 모든 경우를 따지는 문제라고 생각했다.
    
    따라서 완전 탐색을 하면서 중간에서 가지치기를 하는 걸 문제의 핵심 풀이라고 생각했다.
    
2. **구조체를 사용하여 조건을 파싱**
    
    조건이 vector<string>로 주어졌으며, 중간에 쓸데없는 문자가 있기 때문에, 파싱하여 저장했다.
    
3. **캐릭터가 위치한 인덱스를 알아내는 것**
    
    조건을 보면 서로의 거리(인덱스의 차이)가 공통된 조건으로 제시되었다.
    
    이를 통해 만들어진 순서 배열에서 조건들에서 언급된 두 캐릭터의 위치를 찾고 차이를 계산했다.
    
4. **참조의 활용**
    
    여러 함수를 구현하고 배열을 인자로 줘야 하다보니 참조를 사용하게 되었다.
    
    | 형태 | 의미 |
    | --- | --- |
    | auto x | **복사** |
    | auto& x | 원본 참조, **수정 가능** |
    | const auto& x | 원본 참조, **수정 불가** |
5. **고쳐야할 점**
    - 인덱스 찾기를 보편화, 단순화해보자. 지금 너무 통일성 없게 사용되고 있다.
    - visited는 map이 아니라 vector로 단순화하자
    - 인덱스의 활용 방법이 미숙하여 구글링이 길어졌다.
    - next_permutaion(): 서로 다른 n개의 원소에서 r개를 뽑아 한 줄로 세우는 경우의 수
        - 이 문제에서는 do-while문과 함게 사용하면 쉽게 해결 할 수 있다.
        - 다만 모든 순열을 검사하므로 가지치기의 효과는 기대할 수 없다.
        - 이 문제처럼 입력값과 조건이 적다면 Brute Force와 Back Tracking은 비슷하다.

### 제출 코드

```cpp
#include <string>
#include <vector>
#include <algorithm>
#include <unordered_map>

using namespace std;

struct condition {
    int a;
    int b;
    char op;
    int diff;
};

int answer = 0;
vector<string> names = {"A", "C", "F", "J", "M", "N", "R", "T"};
vector<condition> conditions;
unordered_map<string, bool> visited;

int findIndex(string name){
    return find(names.begin(), names.end(), name) - names.begin();
}

bool isValid(const vector<int>& arr, int level){
    auto begin = arr.begin();
    auto endIt = arr.begin() + (level + 1);
    for(const auto& cond : conditions){
        auto itA = find(begin, endIt, cond.a);
        auto itB = find(begin, endIt, cond.b);
        if(itA == endIt || itB == endIt) continue;
        int pos_a = itA - arr.begin();
        int pos_b = itB - arr.begin();
        int actual_diff = abs(pos_a - pos_b) - 1;
        switch(cond.op){
            case '=': if(actual_diff != cond.diff) return false; break;
            case '>': if(actual_diff <= cond.diff) return false; break;
            case '<': if(actual_diff >= cond.diff) return false; break;
        }
    }
    return true;
}

void backtracking(int level, vector<int>& arr){
    if(level == 8){
        answer++;
        return;
    }
    for(int i = 0; i < 8; i++){
        if(!visited[names[i]]){
            visited[names[i]] = true;
            arr[level] = findIndex(names[i]);
            if(isValid(arr, level)){
                backtracking(level + 1, arr);
            }
            arr[level] = -1;
            visited[names[i]] = false;
        }
    }
}

int solution(int n, vector<string> data) {
    answer = 0;
    conditions.clear();
    vector<int> arr = vector<int>(8, -1);
    for (auto &name : names) visited[name] = false;
    for(int i = 0; i < n; i++){
        int index_a = findIndex(string(1, data[i][0]));
        int index_b = findIndex(string(1, data[i][2]));
        char op = data[i][3];
        int diff = data[i][4] - '0';
        conditions.push_back({index_a, index_b, op, diff});
    }
    backtracking(0, arr);
    return answer;
}
```