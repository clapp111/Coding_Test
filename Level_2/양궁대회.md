## 양궁대회 (Lv.2)

[https://school.programmers.co.kr/learn/courses/30/lessons/92342]

### 기록

1. **Back Tracking을 통한 완전 탐색**
    
    가능한 한 많은 점수 차이를 경우를 탐색해야 하기 때문에 완전 탐색이 필요하다고 생각했다.
    
    해당 점수에서 라이언이 이기는지 혹은 지는지를 기준으로 이진 트리를 구상했다. 
    
    배열의 길이도 11로 짧은 편이고 가능한 경우의 수는 2024(2의 11승)으로 완전 탐색을 하기에 문제가 없다고 생각했다.
    
2. **조건에 맞는 탐색 순서**
    
    조건으로 “라이언이 가장 큰 점수 차이로 우승할 수 있는 방법이 여러 가지 일 경우, 가장 낮은 점수를 더 많이 맞힌 경우를 return 해주세요.”가 있기 때문에, 탐색은 0점부터 10점까지 올라가면서 경우를 탐색했다.
    
    또한 코딩의 편의성을 위해, 주어진 배열과 반환할 배열을 임의로 뒤집어서 계산했다.
    
3. **고쳐야할 점**
    - solution()이 여러 번 호출될 수 있는 환경을 고려하면, 전역 변수/배열을 solution()의 시작 부분에서 초기화해야 한다.
    - 나의 생각과 반대로 ‘10점부터 탐색하는 방식’에서 가장 나중에 발견되는 조합이 0점을 많이 맞힌 조합이 된다. 이번 문제에서는 모든 테스트에서 통과하였지만, 아닌 경우가 발생할 수 있어서 위의 방식으로 푸는 것이 정석이다. → 설계 미스

### 제출 코드

```cpp
#include <string>
#include <vector>
#include <algorithm>   

using namespace std;

vector<int> ryan_info(11, 0);
vector<int> answer(11, 0);
int max_diff = 0;

void dfs(int n, const vector<int>& apeach_info, int idx){
    if(idx == 11){
        ryan_info[0] += n;
        int ryan_score = 0;
        int apeach_score = 0;
        for(int i = 0; i < 11; i++){
            if(ryan_info[i] > apeach_info[i]){
                ryan_score += i;
            } else if(apeach_info[i] > 0){
                apeach_score += i;
            }
        }
        if(ryan_score > apeach_score && ryan_score - apeach_score > max_diff){
            max_diff = ryan_score - apeach_score;
            answer = ryan_info;
        }
        ryan_info[0] -= n;
        return;
    }

    int need = apeach_info[idx] + 1;
    if(n >= need){
        ryan_info[idx] = need;
        dfs(n - need, apeach_info, idx + 1);
    }
    ryan_info[idx] = 0;
    dfs(n, apeach_info, idx + 1);
}

vector<int> solution(int n, vector<int> info) {
    reverse(info.begin(), info.end());
    dfs(n, info, 0);
    reverse(answer.begin(), answer.end());
    
    if(max_diff == 0) return {-1};
    else return answer;
}
```